Here is the full content for your README.md file. You can copy and paste this directly into your GitHub repository.Aerio SD Gallery: ESP32 + Arducam Mega 3MPA high-performance, mobile-responsive web server for capturing and managing photos using an Arducam Mega 3MP SPI camera and an SD Card. This project features a modern dark-mode UI, asynchronous photo capture, and an integrated gallery with delete functionality.üöÄ FeaturesReal-time Capture: Trigger the Arducam Mega via a web interface.SD Storage: Automatically saves images with unique timestamps using millis().Modern UI: A clean, CSS-grid-based gallery with a Slate-dark theme.Dual SPI Bus: Optimized performance by isolating the Camera on VSPI and the SD Card on HSPI.File Management: View full-resolution images and delete unwanted photos directly from the browser.Access Point Mode: No router needed; the ESP32 creates its own Wi-Fi network.üõ† Hardware RequiredMicrocontroller: ESP32 (Tested on LilyGo / DevKit V1).Camera: Arducam Mega 3MP SPI Camera.Storage: MicroSD Card Module (Formatted to FAT32).Power: 5V 2A power supply recommended (SPI peripherals are power-hungry).üìå Pinout MappingComponentFunctionESP32 PinArducamCSGPIO 5ArducamSCK / MISO / MOSIGPIO 18 / 19 / 23SD CardCSGPIO 13SD CardSCK / MISO / MOSIGPIO 14 / 2 / 15PowerPeripheral EnableGPIO 4üíª InstallationLibraries: Install the following via the Arduino Library Manager:Arducam_MegaWiFi, WebServer, SD, & FS (Standard ESP32 libs).Configuration: Update the ssid and password variables in the .ino file.Upload: Use the "ESP32 Dev Module" board setting.Connect: Join the Wi-Fi network "Aerio4048" and navigate to http://192.168.4.1.üìù Technical Problem ReportThis project underwent several iterations to resolve hardware-software timing conflicts. Below is the documentation of the challenges and solutions discovered.1. SPI Bus ContentionProblem: Initially, both the Arducam and the SD card shared the default SPI bus. This caused collision errors where the SD card would fail to initialize if the camera was active.Solution: Implemented Dual SPI isolation. By defining a custom SPIClass for the SD card on the HSPI pins while keeping the Camera on the default VSPI bus, both peripherals operate independently without signal interference.2. The "Broken Image" / 0KB File BugProblem: Images appeared in the gallery as broken icons. Serial logs showed tiny file sizes (3KB to 9KB), which indicated the transfer was cutting off prematurely.Solution: Advanced "Burst/Buffered Reads" were clashing with the SPI clock timing of this specific hardware. Reverting to a Byte-by-Byte read loop (file.write(myCAM.readByte())) ensured every single byte from the camera's internal buffer was successfully flushed to the SD card.3. Web Server URI MismatchProblem: The browser requested /IMG_123.jpg, but the SD library sometimes indexed it as IMG_123.jpg (without the slash). This caused 404 errors for the images despite them existing on the card.Solution: Created a Path Normalizer logic. The server now checks for the file in three ways: exactly as requested, with a forced leading slash, and without a leading slash.4. Browser MIME Type SensitivityProblem: Files would send, but mobile browsers wouldn't display them, treating them as binary data.Solution: Added explicit HTTP Header Locking. By sending server.sendHeader("Content-Type", "image/jpeg") before streaming, the browser is forced to interpret the byte stream as a JPEG image.5. SPI Clock StabilityProblem: High-speed SPI (20MHz+) caused the SD card to time out when handled alongside Wi-Fi tasks.Solution: Clocked the SD SPI bus down to 4MHz during initialization to ensure stable data transfer while the ESP32 managed the asynchronous web requests.
